# CRITICAL CONTEXT PROTOCOL

1. **PHASE 1: INDEX CHECK**
   - Before answering ANY architectural or implementation question, you MUST read `docs/00_INDEX.md`.
   - IDENTIFY which branch (Flake, System, User, Profiles) is relevant.

2. **PHASE 2: SCOPED RETRIEVAL**
   - Once the branch is identified, ONLY read the "Key Files" listed in that branch.
   - **NixOS Context:** Pay attention to `lib.mkIf` conditions noted in the index to understand when modules are active.

3. **PHASE 3: IMPLEMENTATION**
   - Proceed with the task using the scoped context.
   - If creating new major modules, remind the user to run `python3 scripts/generate_docs_index.py`.

---

# Cursor Rules for NixOS Flake Configuration

## CRITICAL: PRIME DIRECTIVES (NixOS Flake Architecture)

1.  **Immutability**: This system is immutable. Never suggest editing files in `/nix/store`, `/etc/nixos` (unless symlinked), or running imperative commands like `nix-env`, `nix-channel`, or `apt/yum`.
2.  **Source of Truth**: `flake.nix` is the absolute root. If a package isn't in `inputs`, it cannot be installed.
3.  **Operational Workflow**: `install.sh` is the master controller. It handles `nixos-rebuild switch`, git staging, and generation cleanup.
    * **Dry Runs**: Before suggesting a complex switch, advise running `nixos-rebuild build --flake .#<profile>` to verify syntax.
    * **Application**: Changes are applied via `install.sh` (or `phoenix sync`), never by manual systemd commands.
4.  **Profile Awareness**:
    * **Variables**: `systemSettings`, `userSettings`, and `profile` are passed via `specialArgs` (NixOS) and `extraSpecialArgs` (Home-Manager).
    * **Conditionals**: Use `config = lib.mkIf (config.systemSettings.profile == "DESK") { ... };`.
    * **Inheritance**: Check `nixosConfigurations` in `flake.nix`. Do not duplicate code in a profile config if it belongs in `system/modules/core`.

---

## NixOS-Specific Requirements

### NixOS-First Approach
-   **Always use NixOS-specific solutions** - Never suggest generic Linux commands.
-   **Use NixOS package names** - Check `nixpkgs` availability via `nix search` or [search.nixos.org](https://search.nixos.org).
-   **Follow NixOS configuration patterns** - Use Nix language and NixOS module system.
-   **NixOS file paths** - Use relative paths (`./.`) or `self`. Absolute paths break flake purity.

### Package and Configuration Verification
1.  **Verify package exists** in `inputs` or `nixpkgs`.
2.  **Check NixOS module availability** (e.g., `services.nginx`).
3.  **Use correct attribute paths** (e.g., `pkgs.vim`, `pkgs.python3Packages.requests`).
4.  **Check NixOS options** using `nixos-option` or `search.nixos.org/options`.

### Common Mistakes to Avoid
-   ❌ **DON'T** suggest `apt install`, `yum install`.
-   ❌ **DON'T** suggest editing `/etc/` directly.
-   ❌ **DON'T** suggest manual `systemctl enable` (use NixOS config).
-   ✅ **DO** use `home-manager` modules for user config.

---

## Component Configuration & Best Practices

### System vs User Distinction
-   `environment.systemPackages` = **System-level** (available to all users, root).
-   `home.packages` = **User-level** (Home Manager, per-user).
-   Distinguish between `services.*` (System/NixOS) and `programs.*` (User/Home Manager).

### Waybar-Specific Rules
-   **CSS Parser**: Strict syntax. **Must use `rgba()`**, not 8-digit hex (`#RRGGBBAA`).
-   **Colors**: Prefer Nix functions (e.g., `lib.stylix.colors` with `hexToRgba`).
-   **Regeneration**: Config changes require a rebuild (`install.sh`) or service reload (`systemctl --user reload waybar`).

### Window Manager Isolation
-   **Mutual Exclusivity**: Ensure `programs.sway.enable` and `programs.hyprland.enable` are not accidentally active simultaneously unless intended.
-   **Portals**: Check `xdg.portal` config matches the active WM.
-   **Display Manager**: Check `services.displayManager.sessionPackages` to ensure the WM session is exposed to SDDM.

---

## Documentation Standards

### Structure (3-Level or 4-Level Based on File Size)

**Standard 3-Level Structure** (for files <200 lines):
1.  **Level 1**: `README.md` (Overview).
2.  **Level 2**: `docs/*.md` (Major Topics: installation, configuration, profiles).
3.  **Level 3**: `docs/{subdirectory}/*.md` (Specifics: security, hardware).
4.  **Future/Temp**: `docs/future/*.md` (Planning, bugs, analysis).

**Extended 4-Level Structure** (for files >400 lines to reduce token consumption):
1.  **Level 1**: `README.md` (Overview).
2.  **Level 2**: `docs/{category}.md` (Index/overview - brief, links to Level 3).
3.  **Level 3**: `docs/{category}/{subcategory}/` (Groupings - e.g., `docs/user-modules/applications/`).
4.  **Level 4**: `docs/{category}/{subcategory}/{specific}.md` (Individual topics).
5.  **Future/Temp**: `docs/future/*.md` (Planning, bugs, analysis).

**Decision Rule**: Use 4-level structure when Level 2 files exceed 400 lines to improve maintainability and reduce AI token consumption.

### Format & Maintenance
-   **Markdown Only**: Convert `.org` to `.md` when updating.
-   **Preserve Legacy**: Keep original `.org` files for reference, link them to new `.md` files.
-   **Cross-Referencing**: Extensive linking between levels.
-   **Index Maintenance**: After adding new major modules or restructuring documentation, regenerate the index with `python3 scripts/generate_docs_index.py`. The index (`docs/00_INDEX.md`) is auto-generated and should not be edited manually.
-   **Checklist**:
    -   [ ] Follows 3-level or 4-level structure (based on file size).
    -   [ ] In Markdown format.
    -   [ ] Cross-references added.
    -   [ ] Links to original README files if they exist.
    -   [ ] Index regenerated after structural changes (if applicable).

---

## Code Standards

### Nix Syntax & Style
-   **Indentation**: 2 spaces.
-   **Conditionals**: Prefer `lib.mkIf` over shell script logic inside configs.
-   **Lists**: Use multi-line lists for packages to reduce merge conflicts.
-   **Paths**: Always use relative paths (`./.`) or `self` inputs.
-   **Comments**: Explain *why* a module is enabled, not *what* it does.

### Nix String Interpolation in Shell Scripts
**CRITICAL**: When writing bash/sh scripts inside Nix multiline strings (`''`), you MUST escape bash variable syntax to prevent Nix from interpreting it as Nix variable interpolation.

**The Problem**: In Nix multiline strings (`''`), `${}` is interpreted as Nix variable interpolation, not bash syntax. Writing `${VAR:-default}` causes Nix to try evaluating `VAR` as a Nix variable, leading to errors like `error: undefined variable 'default'`.

**The Solution**: Escape bash variable syntax by doubling the single quotes: `''${VAR}` instead of `${VAR}`.

**Common Patterns That Need Escaping**:
-   `${VAR:-default}` → `''${VAR:-default}` (parameter expansion with default value)
-   `${VAR}` → `''${VAR}` (simple variable reference)
-   `${VAR:+value}` → `''${VAR:+value}` (parameter expansion with alternate value)
-   `${#VAR}` → `''${#VAR}` (parameter length)
-   `${VAR#pattern}` → `''${VAR#pattern}` (parameter prefix removal)
-   `${VAR%pattern}` → `''${VAR%pattern}` (parameter suffix removal)

**Examples**:

❌ **WRONG** (Nix tries to interpret as Nix variable):
```nix
text = ''
  echo "Environment: WAYLAND_DISPLAY=${WAYLAND_DISPLAY:-unset}"
'';
# Error: undefined variable 'unset'
```

✅ **CORRECT** (Escaped for bash):
```nix
text = ''
  echo "Environment: WAYLAND_DISPLAY=''${WAYLAND_DISPLAY:-unset}"
'';
```

**When This Applies**:
-   `pkgs.writeShellApplication` with `text = ''...''`
-   `pkgs.writeShellScriptBin` with `text = ''...''`
-   Any Nix multiline string (`''`) containing bash/sh scripts
-   `home.file` with `text = ''...''` containing shell scripts

**Verification**: Before committing, check that all bash variable references in Nix multiline strings use `''${}` instead of `${}`.

**Reference Examples**: See `user/wm/sway/default.nix` line 27 for correct usage.

### Module Organization
-   Keep modules focused and single-purpose.
-   Access variables via function arguments (`pkgs`, `lib`, `config`, `inputs`).
-   Document module purpose at the top.

---

## SwayFX Daemon Integration System

**CRITICAL**: When modifying daemon-related code, you MUST follow the daemon integration plan to prevent regressions and system breakage.

### When This Rule Applies
This rule applies when:
-   Modifying the `daemons` list in `user/wm/sway/default.nix`
-   Changing `daemon-manager`, `start-sway-daemons`, or `daemon-sanity-check` scripts
-   Modifying Sway startup commands related to daemons
-   Adding/removing Systemd service configurations for daemons
-   **Enabling Home Manager modules that might create Systemd services**

### Required Actions
Before making any changes:
1.  **Read the documentation**: Review `docs/user-modules/sway-daemon-integration.md` to understand the architecture
2.  **Follow DRY principle**: Modify the `daemons` list in `default.nix`, never edit generated scripts directly
3.  **Test changes**: Run `daemon-sanity-check` after modifications
4.  **Verify no conflicts**: Check for Systemd service conflicts
5.  **Check logs**: Review `journalctl --user -t sway-daemon-mgr` after changes

### Systemd Side-Effects Rule
**CRITICAL**: When enabling Home Manager modules (e.g., `programs.waybar.enable = true`), check if they auto-generate Systemd services. If the process is managed by `daemon-manager`, you MUST explicitly disable the Systemd service (e.g., `systemd.enable = false`) to prevent race conditions.

**Example**:
```nix
programs.waybar = {
  enable = true;
  systemd.enable = false;  # Required if managed by daemon-manager
  # ... configuration ...
};
```

**Why**: If both Systemd and `daemon-manager` try to start the same daemon, you get duplicate instances and race conditions.

### Key Principles
1.  **Never edit generated scripts directly** - They are auto-generated from the `daemons` list
2.  **Always modify the `daemons` list** - This is the single source of truth
3.  **Use `match_type = "full"` for NixOS-wrapped binaries** - NixOS wraps binaries (e.g., `waybar` → `.waybar-wrapped`), requiring full command line matching
4.  **Prevent Systemd conflicts** - Always check and disable auto-generated services if managed by `daemon-manager`
5.  **Use safe kill logic** - Never use `pkill -f` directly without filtering `$$` (self PID) and `$PPID` (parent PID) to prevent self-termination
6.  **Use XDG runtime directories for lock files** - Always use `/run/user/$(id -u)/` (XDG runtime directory), never `/tmp/` to prevent security issues and stale locks

### Pattern Check Specificity for Cleanup
**CRITICAL**: When implementing cleanup logic for daemons, pattern checks must be broader than exact matching patterns.

**Example**:
-   ❌ **WRONG**: `if echo "$PATTERN" | grep -q "waybar -c"` (too specific, misses other patterns)
-   ✅ **CORRECT**: `if echo "$PATTERN" | grep -qE "(/bin/)?waybar"` (broader, catches both absolute paths and short commands)

**Why**: Cleanup logic needs to run for multiple pattern formats (old and new), not just the current exact pattern.

**Regex Dialect Note**: Use Extended Regex (ERE) with `grep -E` when validating patterns that will be passed to `pgrep` (which also uses ERE). This ensures consistency between validation and actual matching.

### Pattern Anchoring with Nix Store Paths
**CRITICAL**: When using `pkill -f` with anchored patterns (`^`), account for NixOS absolute store paths.

**NixOS Nuance**: Binaries run from absolute paths (e.g., `/nix/store/...-waybar-.../bin/waybar`). A pattern anchored with `^waybar` will **fail** to match `/nix/store/.../bin/waybar` when using `pkill -f`.

**Example**:
-   ❌ **WRONG**: `pkill -f '^waybar'` (won't match `/nix/store/.../bin/waybar`)
-   ✅ **CORRECT**: `pkill -f '^/nix/store.*/bin/waybar'` (matches full store path)
-   ✅ **ALTERNATIVE**: `pkill -f 'waybar$'` (matches end of command line, works if binary name is consistent)

**Why**: NixOS uses absolute store paths, so regex anchoring must account for the full path prefix. If the start is variable, use end anchoring (`$`) or verify the exact string being matched.

**Verification Tip**: Before defining strict anchors (`^`), verify the actual running process name format using `ps -ef | grep waybar`. The `pgrep -f` matches against `/proc/pid/cmdline`, which might appear short if the process was started via symlink (e.g., `/run/current-system/sw/bin/waybar`).

**Note**: For cleanup operations, prefer broader patterns (e.g., `(/bin/)?waybar` with Extended Regex) that work regardless of store path prefix or command format.

### Diagnostic Logging Best Practices
**CRITICAL**: Always use explicit priority flags in `systemd-cat` logging calls for better debugging.

**Example**:
```sh
# If using the log() wrapper function (defined in daemon-manager):
log "INFO: Starting daemon" "info"    # ✅ CORRECT: Explicit priority
log "WARNING: Process not found" "warning"  # ✅ CORRECT: Explicit priority
log "ERROR: Failed to start" "err"   # ✅ CORRECT: Explicit priority

# If log() wrapper is not available, use systemd-cat directly:
echo "INFO: Starting daemon" | systemd-cat -t sway-daemon-mgr -p info
echo "WARNING: Process not found" | systemd-cat -t sway-daemon-mgr -p warning
echo "ERROR: Failed to start" | systemd-cat -t sway-daemon-mgr -p err
```

**Why**: Explicit priority flags enable better log filtering and debugging (`journalctl -p warning`).

**Note**: The `log()` wrapper function is defined in `daemon-manager` and `daemon-health-monitor` scripts. If implementing logging in a new script, verify the wrapper exists or use `systemd-cat` directly with explicit priority flags.

### Store Path Validation Rule
**CRITICAL**: Always validate extracted store paths before using in pattern matching to prevent false matches.

**Example**:
```sh
CURRENT_STORE_PATH=$(dirname $(dirname "$CLEAN_EXEC"))
# CRITICAL: Validate before use
if [ -z "$CURRENT_STORE_PATH" ] || [ "$CURRENT_STORE_PATH" = "." ]; then
  # Skip store path-based cleanup for invalid paths
  CURRENT_STORE_PATH=""
fi
```

**Why**: Invalid paths (e.g., `.` from legacy patterns) cause `grep -q "."` to match everything, breaking cleanup logic.

### Legacy Pattern Handling
**CRITICAL**: Cleanup logic must handle multiple pattern formats simultaneously during system evolution.

**NixOS-Specific Definition**: In NixOS, a "Legacy Pattern" specifically means **"A process running from a Nix Store path with a different hash than the current configuration"** (e.g., `/nix/store/HASH_A-waybar...` vs `/nix/store/HASH_B-waybar...`). This occurs after system rebuilds when store paths change.

**Why**: During migration or pattern updates, old processes may still be running with old patterns or different store path hashes. Cleanup must handle both.

### String Parsing Best Practices
**CRITICAL**: Prefer `cut` over `awk` for simple field extraction in shell scripts when input format is predictable.

**Example**:
-   ✅ **CORRECT**: `CLEAN_EXEC=$(echo "$PATTERN" | cut -d' ' -f1 | sed 's/^\^//')` (for strictly formatted strings like Nix store paths)
-   ⚠️ **ACCEPTABLE**: `CLEAN_EXEC=$(echo "$PATTERN" | awk '{print $1}' | sed 's/^\^//')` (if whitespace is variable/unpredictable)

**Why**: `cut` is lighter weight (part of `coreutils`) and more appropriate for simple field extraction in restricted shell environments. However, `awk` is more robust if input has variable whitespace (e.g., multiple spaces between command and argument). For extracting binary paths from known command strings (like Nix store paths), `cut` is preferred.

**Note**: Ensure `coreutils` is available in the environment for `cut` to work.

**Regex Dialect Compatibility**: When validating patterns that will be passed to `pgrep` (which uses Extended Regex - ERE), use `grep -E` instead of standard `grep` (which uses Basic Regex - BRE) to ensure consistency. Example: `grep -qE "(/bin/)?waybar"` instead of `grep -q "/bin/waybar"`.

### TOCTOU Race Conditions (Already Solved)
**CRITICAL**: The current implementation already solves TOCTOU race conditions correctly using `safe_kill()` and `safe_kill_pid()` functions.

**Current Working Approach** (DO NOT CHANGE):
-   Uses `safe_kill()` function which uses `pgrep` + `kill` (SIGTERM) with PID filtering
-   Uses `safe_kill_pid()` function for PID-based cleanup with SIGKILL
-   **Line 604 in `default.nix`**: "Note: We no longer use pkill - safe_kill uses pgrep + kill instead"

**What NOT to Do**:
-   ❌ **WRONG**: `pid=$(pgrep -f pattern); kill $pid` (TOCTOU race condition)
-   ❌ **WRONG**: `pkill -f pattern` directly (causes self-termination)
-   ❌ **WRONG**: `pkill -USR2 -f pattern` for cleanup (SIGUSR2 is for reload, not kill)

**What to Do** (Already Implemented):
-   ✅ **CORRECT**: Use existing `safe_kill()` or `safe_kill_pid()` functions
-   ✅ **CORRECT**: SIGUSR2 is ONLY used for reload commands (already correctly implemented)

**Why This Works**: `safe_kill()` gets all PIDs with `pgrep`, filters out `$$` (self PID) and `$PPID` (parent PID) to prevent self-termination, then kills remaining PIDs. This solves both TOCTOU race conditions and self-termination bugs.

**Technical Detail**: The specific mechanism that solves self-termination is the explicit filtering of `$$` and `$PPID` before killing. Standard `pkill` does not do this easily, which is why `safe_kill` is mandatory. This filtering ensures the script never kills itself or its parent process, even if the pattern matches the script's own command line arguments.

**Reference**: See `sway-daemon-integration.md` Safe Kill Functions section for details.

### Dependency Availability
**CRITICAL**: Ensure required binaries are available in the environment when implementing daemon management scripts.

**Required Dependencies**:
-   `procps` (provides `pkill`, `pgrep`) - Required for process management
-   `coreutils` (provides `cut`, `dirname`) - Required for string parsing and path manipulation
-   `gnugrep` (provides `grep`) - Usually available, but verify if using strict derivations

**NixOS Context**: In NixOS shell scripts (especially inside `systemd` units or strict derivations), these binaries might not be in the default `$PATH` unless explicitly added.

**Example**:
```nix
# In daemon-manager script generation, ensure packages are available:
daemon-manager = pkgs.writeShellScriptBin "daemon-manager" ''
  # Use explicit paths from pkgs
  ${pkgs.procps}/bin/pkill -f pattern
  ${pkgs.coreutils}/bin/cut -d' ' -f1
'';
```

**Why**: NixOS uses isolated environments. Scripts must explicitly reference package paths or ensure packages are in the environment's `PATH`.

### Lock File Mechanism Rules
**CRITICAL**: The lock file mechanism MUST use the simple atomic design:
-   ✅ **CORRECT**: `flock -n 9 || { echo "..."; exit 0; }` - immediate exit if lock held
-   ❌ **FORBIDDEN**: Retry logic with `sleep` and double-check - creates race conditions
-   ❌ **FORBIDDEN**: `flock -w` with timeout - unnecessary complexity
-   **Why**: The simple design prevents race conditions. Any retry logic allows multiple processes to pass the lock check.

### Startup Script Timing Rules
**CRITICAL**: Startup scripts MUST NOT add unnecessary delays:
-   ✅ **CORRECT**: Simple, fast startup with minimal delays
-   ❌ **FORBIDDEN**: Blocking config validation that delays startup
-   ❌ **FORBIDDEN**: Final verification checks that add 2+ second delays
-   ❌ **FORBIDDEN**: Multiple sleep statements in startup sequence
-   **Why**: Added delays interfere with daemon timing, especially Wayland initialization.

### Daemon Manager Verification Rules
**CRITICAL**: Verification timing MUST be appropriate for each daemon:
-   ✅ **CORRECT**: Standard verification (0.5s, 1s, 2s) for most daemons
-   ✅ **CORRECT**: Extended verification for waybar (add post-verification check after 2s)
-   ❌ **FORBIDDEN**: Too-short verification that doesn't catch crashes
-   ❌ **FORBIDDEN**: Too-long verification that delays startup unnecessarily
-   **Why**: Waybar needs extra time for Wayland connection, but other daemons don't.

### Testing Requirements
**CRITICAL**: Before committing daemon-related changes:
1.  **Check git history** - Review working commits (e.g., `00dadd0`) to understand original design
2.  **Test lock mechanism** - Verify no race conditions with rapid reloads
3.  **Test waybar startup** - Verify waybar starts and stays running
4.  **Test reload** - Verify `swaymsg reload` doesn't cause conflicts
5.  **Check logs** - Review `journalctl --user -t sway-daemon-mgr` for errors
6.  **Verify no orphaned processes** - Check for leftover tail processes

### Checklist
When modifying daemon-related code:

-   [ ] Read `docs/user-modules/sway-daemon-integration.md`
-   [ ] Modified `daemons` list (not generated scripts)
-   [ ] Used `match_type = "full"` for NixOS-wrapped binaries
-   [ ] Checked for Systemd service conflicts and disabled if needed
-   [ ] Used safe kill logic (filtered `$$` and `$PPID`)
-   [ ] Used XDG runtime directory for lock files (`/run/user/$(id -u)/`)
-   [ ] Tested with `daemon-sanity-check`
-   [ ] Verified logs with `journalctl --user -t sway-daemon-mgr`
-   [ ] No duplicate instances after reload

### Common Mistakes to Avoid
-   ❌ **DON'T** edit generated scripts directly (they're auto-generated)
-   ❌ **DON'T** use `match_type = "exact"` for NixOS-wrapped binaries
-   ❌ **DON'T** forget to disable Systemd services for daemons managed by `daemon-manager`
-   ❌ **DON'T** use `pkill -f` without filtering `$$` and `$PPID`
-   ❌ **DON'T** use `/tmp/` for lock files (use `/run/user/$(id -u)/`)
-   ❌ **DON'T** add retry logic to lock file mechanism (creates race conditions)
-   ❌ **DON'T** add blocking delays to startup scripts (interferes with timing)
-   ❌ **DON'T** add final verification checks that delay startup (redundant with daemon-manager)
-   ✅ **DO** modify the `daemons` list in `default.nix`
-   ✅ **DO** use `match_type = "full"` for all NixOS-wrapped binaries
-   ✅ **DO** check for Systemd conflicts when enabling Home Manager modules
-   ✅ **DO** use safe kill logic that filters self and parent PIDs
-   ✅ **DO** use XDG runtime directories for lock files
-   ✅ **DO** use simple atomic lock mechanism (no retry logic)
-   ✅ **DO** check git history before modifying daemon code
-   ✅ **DO** test daemon changes with actual Sway session before committing

### Reference Documentation
-   **Primary Guide**: `docs/user-modules/sway-daemon-integration.md` - Complete architecture and usage guide
-   **Source Code**: `user/wm/sway/default.nix` (lines 36-111 for daemon list, lines 114-355 for script generation)
-   **Systemd Example**: `user/wm/sway/waybar.nix` (line 8) - Example of disabling Systemd service

---

## DESK Startup Applications Script

**CRITICAL**: When adding new automation to the beginning of Sway sessions (startup scripts that launch applications), you MUST check and potentially extend the existing `desk-startup-apps` scripts instead of creating new startup commands.

### When This Rule Applies
This rule applies when:
-   Adding applications to launch automatically at Sway startup
-   Creating new startup automation scripts for the DESK profile
-   Modifying application launch sequences at session start
-   Adding new applications to the DESK startup workflow

### Required Actions
Before creating new startup automation:
1.  **Check Existing Scripts**: Review `user/wm/sway/default.nix` for the `desk-startup-apps-init` and `desk-startup-apps-launcher` definitions (generated in the `let` block)
2.  **Use Assignment Rules**: Use Sway assignment rules (`assign [app_id="..."] workspace number X`) in `window.commands` to route apps to correct workspaces. Support both Flatpak and native app IDs.
3.  **Extend Existing Script**: Modify the `desk-startup-apps-launcher` script's `launch_apps()` function instead of creating new startup commands
4.  **Follow Parallel Launch Pattern**: Launch apps in parallel (background processes with `&`) - Sway assign rules handle workspace placement automatically
5.  **Respect DESK Profile**: The scripts are conditional on DESK profile (`systemSettings.swayPrimaryMonitor != null`) - maintain this pattern
6.  **Handle Flatpak Apps**: Check if apps are installed via Flatpak and launch accordingly using `flatpak run APP_ID`

### Architecture
The `desk-startup-apps` system uses a 2-script approach:
-   **desk-startup-apps-init**: Non-blocking initialization script that runs in Sway startup sequence
    - Sets up workspaces (fast, non-blocking)
    - Shows rofi password dialog with explanation
    - Attempts to unlock KWallet with entered password (using kwalletcli)
    - Launches background launcher script (if not cancelled)
    - Exits immediately (system continues starting normally)
-   **desk-startup-apps-launcher**: Background app launcher with persistent KWallet monitoring
    - Monitors KWallet unlock status (checks every 2 seconds)
    - Reopens KWallet prompt if closed (with rofi password dialog option)
    - Sends desktop notifications
    - Launches apps when unlocked (all apps launch in parallel)
    - Implements backoff strategy to prevent infinite loops
    - Runs until KWallet is unlocked or user cancels

**Key Features**:
- Non-blocking system startup (system continues immediately)
- Rofi password entry integration (masked input, secure password passing via here-strings)
- Flatpak app detection and launching
- Persistent KWallet prompting with user cancellation options
- Parallel app launching (all apps launch simultaneously when KWallet is unlocked)
- Infinite loop prevention (backoff strategy, max failures)

### Key Principles
1.  **Use Assignment Rules**: Always define `assign` rules in `window.commands` before adding apps to the launcher script. Support both Flatpak and native app IDs (e.g., `app_id="com.vivaldi.Vivaldi"` and `app_id="vivaldi"`).
2.  **Parallel Launch**: Launch all apps in parallel using `&` - Sway assign rules handle workspace placement automatically (no focus switching needed)
3.  **Conditional Execution**: Scripts check for DESK profile and exit early on other profiles
4.  **No Config Reload Execution**: Init script uses `always = false` to only run on initial startup
5.  **KWallet Awareness**: System waits for KWallet unlock before launching apps, but doesn't block system startup
6.  **Flatpak Support**: Check if apps are installed via Flatpak using `flatpak list` or `flatpak info`, launch with `flatpak run APP_ID`
7.  **Security**: Use here-strings (`<<<`) for password passing, not pipes, to prevent password leakage in debug mode

### Implementation Pattern
```nix
# 1. Add assignment rules in window.commands (support both Flatpak and native)
assign [app_id="com.myapp.App"] workspace number X  # Flatpak
assign [app_id="myapp"] workspace number X  # Native

# 2. Add app to launch_apps() function in desk-startup-apps-launcher
# Check if Flatpak first, then fallback to native
if is_flatpak_installed "com.myapp.App"; then
  flatpak run com.myapp.App >/dev/null 2>&1 &
else
  command -v myapp >/dev/null 2>&1 && myapp >/dev/null 2>&1 & || true
fi
```

### Reference Documentation
-   **Script Locations**: `user/wm/sway/default.nix` (generated scripts in `let` block, startup command in `startup` list)
-   **Init Script**: `desk-startup-apps-init` - Non-blocking initialization with rofi password dialog
-   **Launcher Script**: `desk-startup-apps-launcher` - Background app launcher with KWallet monitoring
-   **Assignment Rules**: `user/wm/sway/default.nix` (`window.commands` section)
-   **Startup Command**: `user/wm/sway/default.nix` (`startup` list, after `daemon-sanity-check`)

---

## Git Commit Guidelines

### Documentation First

Before committing, verify documentation impact:

1. **Review**: Check if changes affect documented features.
2. **Update**: Update `docs/*.md` files (Level 2 or 3).
3. **Create**: If adding features, create new docs.
4. **Message**: Mention docs in commit (e.g., "Add feature X and update documentation").

### Automated Checks

*   **Configuration Change**: Update `docs/configuration.md` and module docs.
*   **Script Change**: Update `docs/scripts.md`.
*   **Module Change**: Update `docs/system-modules.md` or `docs/user-modules.md`.
*   **New Feature**: Add to `docs/future/` or `docs/`.
