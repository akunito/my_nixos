{ config, pkgs, lib, userSettings, systemSettings, ... }:

let
  # Hyper key combination (Super+Ctrl+Alt)
  hyper = "Mod4+Control+Mod1";
  
  # DESK startup apps script - launches applications in specific workspaces after daemons are ready
  desk-startup-apps-script = pkgs.writeShellScriptBin "desk-startup-apps" ''
    #!/bin/bash
    PRIMARY="${if systemSettings.swayPrimaryMonitor != null then systemSettings.swayPrimaryMonitor else ""}"
    
    if [ -z "$PRIMARY" ]; then
      # Not DESK profile, exit
      exit 0
    fi
    
    # Wait a moment for everything to settle
    sleep 2
    
    # Phase 1: Smart wait for KWallet prompt (before launching apps that need it)
    KWALLET_FOUND=false
    for i in $(seq 1 5); do
      KWALLET_WINDOW=$(${pkgs.sway}/bin/swaymsg -t get_tree 2>/dev/null | ${pkgs.jq}/bin/jq -r '
        recurse(.nodes[]?) 
        | select(.type=="con" or .type=="floating_con")
        | select(.name != null)
        | select(.name | test("(?i)(kde.?wallet|kwallet)"; "i"))
        | .id' 2>/dev/null | head -1)
      
      if [ -n "$KWALLET_WINDOW" ] && [ "$KWALLET_WINDOW" != "null" ]; then
        KWALLET_FOUND=true
        break
      fi
      sleep 1
    done
    
    if [ "$KWALLET_FOUND" = "true" ]; then
      # Wait for KWallet window to close
      while [ -n "$(${pkgs.sway}/bin/swaymsg -t get_tree 2>/dev/null | ${pkgs.jq}/bin/jq -r "recurse(.nodes[]?) | select(.id == $KWALLET_WINDOW) | .id" 2>/dev/null | ${pkgs.gnugrep}/bin/grep -v null)" ]; do
        sleep 0.5
      done
    fi
    
    # Phase 2: Launch Vivaldi (blocking, after KWallet is handled)
    ${pkgs.sway}/bin/swaymsg focus output "$PRIMARY"
    ${pkgs.swaysome}/bin/swaysome focus 1
    ${pkgs.flatpak}/bin/flatpak run com.vivaldi.Vivaldi >/dev/null 2>&1 &
    
    # Wait for Vivaldi window to appear (max 30 seconds)
    VIVALDI_READY=false
    for i in $(seq 1 30); do
      if ${pkgs.sway}/bin/swaymsg -t get_tree 2>/dev/null | ${pkgs.jq}/bin/jq -r 'recurse(.nodes[]?) | select(.app_id == "com.vivaldi.Vivaldi") | .id' 2>/dev/null | ${pkgs.gnugrep}/bin/grep -q '[0-9]'; then
        VIVALDI_READY=true
        break
      fi
      sleep 1
    done
    
    # Phase 3: Parallel launch Cursor, Obsidian, and Chromium
    cursor --enable-features=UseOzonePlatform,WaylandWindowDecorations --ozone-platform=wayland --ozone-platform-hint=auto --unity-launch >/dev/null 2>&1 &
    obsidian --no-sandbox --ozone-platform=wayland --ozone-platform-hint=auto --enable-features=UseOzonePlatform,WaylandWindowDecorations >/dev/null 2>&1 &
    chromium >/dev/null 2>&1 &
  '';
  
  # Daemon definitions - shared by all generated scripts (DRY principle)
  # WARNING: Sway and Hyprland both use programs.waybar which writes to
  # ~/.config/waybar/config. They are mutually exclusive in the same profile.
  # If both WMs are enabled, Home Manager will have a file conflict.
  daemons = [
    {
      name = "waybar";
      # Explicit config path ensures waybar uses the correct config file
      # generated by programs.waybar.settings (Sway-specific modules)
      command = "${pkgs.waybar}/bin/waybar -c ${config.xdg.configHome}/waybar/config";
      pattern = "/bin/waybar";  # More specific to avoid matching swaybar (SwayFX internal bar)
      match_type = "full";  # Essential for .waybar-wrapped (NixOS wrapper)
      reload = "${pkgs.procps}/bin/pkill -f -SIGUSR2 /bin/waybar";  # Hot reload CSS/config (needs -f for wrapped process, specific pattern)
      requires_sway = true;
    }
    {
      name = "swaync";
      command = "${pkgs.swaynotificationcenter}/bin/swaync";
      pattern = "swaync";
      match_type = "full";  # Fixes "An instance is already running" (NixOS wrapper)
      reload = "${pkgs.swaynotificationcenter}/bin/swaync-client -R";
      requires_sway = true;
    }
    {
      name = "nm-applet";
      command = "${pkgs.networkmanagerapplet}/bin/nm-applet --indicator";
      pattern = "nm-applet";
      match_type = "full";  # NixOS wrapper
      reload = "";
      requires_sway = false;
      requires_tray = true;  # Wait for waybar's tray (StatusNotifierWatcher) to be ready
    }
    {
      name = "blueman-applet";
      command = "${pkgs.blueman}/bin/blueman-applet";
      pattern = "blueman-applet";
      match_type = "full";  # NixOS wrapper
      reload = "";
      requires_sway = false;
      requires_tray = true;  # Wait for waybar's tray (StatusNotifierWatcher) to be ready
    }
    {
      name = "cliphist";
      command = "${pkgs.wl-clipboard}/bin/wl-paste --watch ${pkgs.cliphist}/bin/cliphist store";
      pattern = "wl-paste.*cliphist";  # Regex pattern for full command match
      match_type = "full";  # Use pgrep -f for full command match (needed for complex commands)
      reload = "";
      requires_sway = true;
    }
    {
      name = "kwalletd6";
      command = "${pkgs.kdePackages.kwallet}/bin/kwalletd6";
      pattern = "kwalletd6";
      match_type = "full";  # KDE daemons are always wrapped on NixOS
      reload = "";
      requires_sway = false;
    }
  ] ++ lib.optionals (
    # Only include libinput-gestures on laptop systems (has touchpad)
    # Desktop systems (DESK, AGADESK, VMDESK) don't have touchpads
    lib.hasInfix "laptop" (lib.toLower systemSettings.hostname) ||
    lib.hasInfix "yoga" (lib.toLower systemSettings.hostname)
  ) [
    {
      name = "libinput-gestures";
      command = "${pkgs.libinput-gestures}/bin/libinput-gestures";
      pattern = "libinput-gestures";
      match_type = "full";  # Python script/wrapper - full match required
      reload = "";
      requires_sway = true;  # Needs SwayFX IPC to send workspace commands
    }
  ] ++ lib.optional (systemSettings.sunshineEnable == true) {
    name = "sunshine";
    command = "${pkgs.sunshine}/bin/sunshine";
    pattern = "sunshine";
    match_type = "full";  # NixOS wrapper - full match required
    reload = "";
    requires_sway = false;
    requires_tray = true;  # Wait for waybar's tray (StatusNotifierWatcher) to be ready
  } ++ lib.optional (systemSettings.stylixEnable == true && (userSettings.wm != "plasma6" || systemSettings.enableSwayForDESK == true)) {
    name = "swaybg";
    command = "${pkgs.swaybg}/bin/swaybg -i ${config.stylix.image} -m fill";
    pattern = "swaybg";
    match_type = "full";  # NixOS wrapper - full match required
    reload = "";
    requires_sway = true;
  };
  
  # Generate daemon-manager script
  daemon-manager = pkgs.writeShellScriptBin "daemon-manager" ''
    #!/bin/sh
    # Unified daemon manager for SwayFX
    # Usage: daemon-manager [PATTERN] [MATCH_TYPE] [COMMAND] [RELOAD_CMD] [REQUIRES_SWAY] [REQUIRES_TRAY]
    
    PATTERN="$1"
    MATCH_TYPE="$2"
    COMMAND="$3"
    RELOAD_CMD="$4"
    REQUIRES_SWAY="$5"
    REQUIRES_TRAY="$6"
    
    # Determine pgrep flags based on match_type
    # Note: We no longer use pkill - safe_kill uses pgrep + kill instead
    if [ "$MATCH_TYPE" = "exact" ]; then
      PGREP_FLAG="-x"
    else
      PGREP_FLAG="-f"
    fi
    
    # Logging function using systemd-cat
    # systemd-cat is a standard system utility available in PATH
    log() {
      echo "$1" | systemd-cat -t sway-daemon-mgr -p "$2"
    }
    
    # Safe kill function - prevents self-termination by excluding script's own PID and parent PID
    # CRITICAL: pkill -f matches command line arguments, which can include the pattern we're searching for
    # This causes the script to kill itself. This function filters out $$ and $PPID before killing.
    safe_kill() {
      local KILL_PATTERN="$1"
      local KILL_PGREP_FLAG="$2"
      local SELF_PID=$$
      local PARENT_PID=$PPID
      local KILLED_COUNT=0
      
      # Get all matching PIDs
      MATCHING_PIDS=$(${pkgs.procps}/bin/pgrep $KILL_PGREP_FLAG "$KILL_PATTERN" 2>/dev/null || echo "")
      
      if [ -z "$MATCHING_PIDS" ]; then
        return 0
      fi
      
      # Filter and kill (exclude self and parent)
      for PID in $MATCHING_PIDS; do
        if [ "$PID" != "$SELF_PID" ] && [ "$PID" != "$PARENT_PID" ]; then
          kill "$PID" 2>/dev/null && KILLED_COUNT=$((KILLED_COUNT + 1)) || true
        fi
      done
      return 0
    }
    
    # Check if process is running and count instances
    RUNNING_PIDS=$(${pkgs.procps}/bin/pgrep $PGREP_FLAG "$PATTERN" 2>/dev/null || echo "")
    RUNNING_COUNT=$(echo "$RUNNING_PIDS" | grep -v "^$" | wc -l)
    
    if [ -n "$RUNNING_PIDS" ] && [ "$RUNNING_COUNT" -gt 0 ]; then
      # Process(es) running - check for duplicates
      if [ "$RUNNING_COUNT" -gt 1 ]; then
        # Multiple instances detected - kill all and restart with exponential backoff
        log "WARNING: Multiple instances detected ($RUNNING_COUNT), killing all: $PATTERN" "warning"
        safe_kill "$PATTERN" "$PGREP_FLAG"
        
        # Exponential backoff verification: wait progressively longer to ensure processes are dead
        # This prevents race conditions where processes are still terminating
        REMAINING=$RUNNING_COUNT
        for wait_time in 0.5 1 2; do
          sleep $wait_time
          REMAINING=$(${pkgs.procps}/bin/pgrep $PGREP_FLAG "$PATTERN" 2>/dev/null | wc -l)
          if [ "$REMAINING" -eq 0 ]; then
            break
          fi
          # If processes still exist, try killing again (they might have been in a bad state)
          if [ "$REMAINING" -gt 0 ]; then
            log "WARNING: Still $REMAINING processes remaining, attempting kill again: $PATTERN" "warning"
            safe_kill "$PATTERN" "$PGREP_FLAG"
          fi
        done
        
        # Final verification: if processes still exist after all attempts, log warning but proceed
        if [ "$REMAINING" -gt 0 ]; then
          log "WARNING: $REMAINING processes still remaining after kill attempts, proceeding anyway: $PATTERN" "warning"
        else
          log "All duplicate processes successfully terminated: $PATTERN" "info"
        fi
        
        log "Falling through to start fresh instance after killing duplicates: $PATTERN" "info"
        # CRITICAL: Force fall-through by clearing RUNNING_COUNT so we don't hit the single-instance check below
        RUNNING_COUNT=0
        RUNNING_PIDS=""
        # Fall through to start fresh instance
      elif [ -n "$RELOAD_CMD" ]; then
        # Single instance running and supports reload - send reload signal
        # For waybar, use direct kill with PID to avoid pkill -f self-matching
        # For other daemons (e.g., swaync-client -R), use the reload command
        if echo "$RELOAD_CMD" | grep -q "pkill.*-f"; then
          # Reload command uses pkill -f, use PID instead to avoid self-matching
          if [ -n "$RUNNING_PIDS" ]; then
            log "Sending reload signal to daemon PID: $RUNNING_PIDS (pattern: $PATTERN)" "info"
            kill -SIGUSR2 $RUNNING_PIDS 2>/dev/null || {
              log "WARNING: Direct kill failed, using reload command" "warning"
              eval "$RELOAD_CMD"
            }
          else
            eval "$RELOAD_CMD"
          fi
        else
          # Reload command doesn't use pkill -f, safe to use directly
          eval "$RELOAD_CMD"
        fi
        log "Reload signal sent to daemon: $PATTERN (PID: $RUNNING_PIDS)" "info"
        exit 0
      else
        # Single instance running but no reload support - leave it running
        log "Daemon already running: $PATTERN (PID: $RUNNING_PIDS)" "info"
        exit 0
      fi
    fi
    
    # Process not running - start it
    if [ "$REQUIRES_SWAY" = "true" ]; then
      # Wait for SwayFX IPC to be ready (max 10 seconds)
      SWAY_READY=false
      for i in $(seq 1 10); do
        if ${pkgs.swayfx}/bin/swaymsg -t get_outputs > /dev/null 2>&1; then
          SWAY_READY=true
          break
        fi
        sleep 1
      done
      if [ "$SWAY_READY" = "false" ]; then
        log "WARNING: SwayFX not ready after 10 seconds, starting daemon anyway: $PATTERN" "warning"
      fi
    fi
    
    if [ "$REQUIRES_TRAY" = "true" ]; then
      # Wait for StatusNotifierWatcher to be ready (exponential backoff: 0.5s, 1s, 2s, 4s, 8s = 15.5s total)
      # NOTE: On Sway/Hyprland, Waybar itself acts as the StatusNotifierWatcher when its tray module is enabled
      # This ensures waybar's tray module has registered before applets try to connect
      TRAY_READY=false
      TOTAL_WAIT=0
      CHECK_COUNT=0
      for delay in 0.5 1 2 4 8; do
        # Check if org.freedesktop.StatusNotifierWatcher is available on DBus
        # This checks if Waybar (or another watcher) has registered the service
        if ${pkgs.dbus}/bin/dbus-send --session --print-reply \
          --dest=org.freedesktop.DBus \
          /org/freedesktop/DBus \
          org.freedesktop.DBus.GetNameOwner \
          string:org.freedesktop.StatusNotifierWatcher > /dev/null 2>&1; then
          TRAY_READY=true
          log "StatusNotifierWatcher is ready (check #$CHECK_COUNT, waited ~''${TOTAL_WAIT} seconds)" "info"
          break
        fi
        CHECK_COUNT=$((CHECK_COUNT + 1))
        # Sleep before next check (exponential backoff)
        sleep $delay
        # Approximate total wait (using integer arithmetic)
        TOTAL_WAIT=$((TOTAL_WAIT + 1))  # Approximate, close enough for logging
      done
      if [ "$TRAY_READY" = "false" ]; then
        log "WARNING: StatusNotifierWatcher not ready after ~15 seconds, starting daemon anyway: $PATTERN" "warning"
        log "NOTE: Tray icon may not appear until waybar's tray module initializes" "info"
      fi
    fi
    
    # Kill any stale processes (safety check even though we checked above)
    # Use safe_kill to prevent self-termination
    safe_kill "$PATTERN" "$PGREP_FLAG"
    sleep 0.5
    
    # Final verification: ensure no processes are running before starting
    FINAL_CHECK=$(${pkgs.procps}/bin/pgrep $PGREP_FLAG "$PATTERN" 2>/dev/null | wc -l)
    if [ "$FINAL_CHECK" -gt 0 ]; then
      log "WARNING: $FINAL_CHECK processes still running before start, killing again: $PATTERN" "warning"
      safe_kill "$PATTERN" "$PGREP_FLAG"
      sleep 1
    fi
    
    # Start daemon with systemd logging
    log "Starting daemon: $PATTERN (command: $COMMAND)" "info"
    nohup sh -c "$COMMAND" 2>&1 | systemd-cat -t "sway-daemon-''${PATTERN}" &
    DAEMON_PID=$!
    log "Daemon start command executed, PID: $DAEMON_PID" "info"
    
    # Verify it started with progressive wait (some daemons take longer to initialize)
    # Use exponential backoff: check quickly first, then wait longer
    DAEMON_STARTED=false
    for check_delay in 0.5 1 2; do
      sleep $check_delay
      if ${pkgs.procps}/bin/pgrep $PGREP_FLAG "$PATTERN" > /dev/null 2>&1; then
        ACTUAL_PID=$(${pkgs.procps}/bin/pgrep $PGREP_FLAG "$PATTERN" 2>/dev/null | head -1)
        log "Daemon started successfully: $PATTERN (started PID: $DAEMON_PID, actual PID: $ACTUAL_PID, verified after ''${check_delay}s)" "info"
        DAEMON_STARTED=true
        break
      fi
    done
    
    if [ "$DAEMON_STARTED" = "false" ]; then
      # Additional check: see if process started but verification failed
      CHECK_CMD=$(ps -p $DAEMON_PID -o comm= 2>/dev/null || echo "not_found")
      log "ERROR: Failed to start daemon: $PATTERN (started PID: $DAEMON_PID, process: $CHECK_CMD)" "err"
      exit 1
    fi
  '';
  
  # Generate startup script (iterates daemon list)
  start-sway-daemons = pkgs.writeShellScriptBin "start-sway-daemons" ''
    #!/bin/sh
    # Auto-generated script - starts all SwayFX daemons
    # Do not edit manually - generated from daemon list in default.nix
    
    # File locking to prevent concurrent execution (e.g., rapid reload spam)
    # Uses XDG runtime directory which is automatically cleaned on logout/reboot
    LOCK_FILE="/run/user/$(id -u)/sway-startup.lock"
    (
      # Try to acquire lock with timeout (5 seconds) to prevent indefinite blocking
      # If lock is held, wait briefly then exit gracefully
      if ! flock -n 9; then
        # Lock is held - wait a bit to see if it releases
        sleep 1
        if ! flock -n 9; then
          echo "Another startup process is running, exiting gracefully" | systemd-cat -t sway-daemon-mgr -p info
          exit 0
        fi
      fi
      
      # Start waybar first (synchronously) to avoid race conditions
      # Waybar is critical and multiple parallel instances cause conflicts
      ${lib.concatMapStringsSep "\n" (daemon: ''
        if [ "${daemon.name}" = "waybar" ]; then
          ${daemon-manager}/bin/daemon-manager \
            ${lib.strings.escapeShellArg daemon.pattern} \
            ${lib.strings.escapeShellArg daemon.match_type} \
            ${lib.strings.escapeShellArg daemon.command} \
            ${lib.strings.escapeShellArg (if daemon.reload != "" then daemon.reload else "")} \
            ${if daemon.requires_sway then "true" else "false"} \
            ${if daemon.requires_tray or false then "true" else "false"}
        fi
      '') daemons}
      
      # Start all other daemons in parallel
      ${lib.concatMapStringsSep "\n" (daemon: ''
        if [ "${daemon.name}" != "waybar" ]; then
          ${daemon-manager}/bin/daemon-manager \
            ${lib.strings.escapeShellArg daemon.pattern} \
            ${lib.strings.escapeShellArg daemon.match_type} \
            ${lib.strings.escapeShellArg daemon.command} \
            ${lib.strings.escapeShellArg (if daemon.reload != "" then daemon.reload else "")} \
            ${if daemon.requires_sway then "true" else "false"} \
            ${if daemon.requires_tray or false then "true" else "false"} &
        fi
      '') daemons}
      wait
    ) 9>"$LOCK_FILE"
  '';
  
  # Generate sanity check script (uses same daemon list)
  daemon-sanity-check = pkgs.writeShellScriptBin "daemon-sanity-check" ''
    #!/bin/sh
    # Auto-generated script - checks status of all SwayFX daemons
    # Do not edit manually - generated from daemon list in default.nix
    
    FIX_MODE=false
    if [ "$1" = "--fix" ]; then
      FIX_MODE=true
    fi
    
    ALL_RUNNING=true
    ${lib.concatMapStringsSep "\n" (daemon: ''
      MATCH_TYPE=${lib.strings.escapeShellArg daemon.match_type}
      if [ "$MATCH_TYPE" = "exact" ]; then
        PGREP_FLAG="-x"
      else
        PGREP_FLAG="-f"
      fi
      
      if ${pkgs.procps}/bin/pgrep $PGREP_FLAG ${lib.strings.escapeShellArg daemon.pattern} > /dev/null 2>&1; then
        echo "✓ ${daemon.name} is running" | systemd-cat -t sway-daemon-check -p info
      else
        echo "✗ ${daemon.name} is NOT running" | systemd-cat -t sway-daemon-check -p warning
        ALL_RUNNING=false
        if [ "$FIX_MODE" = "true" ]; then
          ${daemon-manager}/bin/daemon-manager \
            ${lib.strings.escapeShellArg daemon.pattern} \
            ${lib.strings.escapeShellArg daemon.match_type} \
            ${lib.strings.escapeShellArg daemon.command} \
            ${lib.strings.escapeShellArg (if daemon.reload != "" then daemon.reload else "")} \
            ${if daemon.requires_sway then "true" else "false"} \
            ${if daemon.requires_tray or false then "true" else "false"}
        fi
      fi
    '') daemons}
    
    if [ "$ALL_RUNNING" = "true" ]; then
      exit 0
    else
      exit 1
    fi
  '';
in {

  imports = [
    ../../app/terminal/alacritty.nix
    ../../app/terminal/kitty.nix
    ../../app/terminal/tmux.nix
    ../../app/gaming/mangohud.nix
    ../../app/ai/aichat.nix
    ../../shell/sh.nix
  ];

  # CRITICAL: Portal configuration to avoid conflicts with KDE
  xdg.portal = {
    enable = true;
    extraPortals = with pkgs; [
      xdg-desktop-portal-wlr
      xdg-desktop-portal-gtk
    ];
    config = {
      sway = {
        default = [ "wlr" "gtk" ];
      };
    };
  };

  # CRITICAL: Idle daemon with swaylock-effects
  services.swayidle = {
    enable = true;
    timeouts = [
      {
        timeout = 600; # 10 minutes
        command = "${pkgs.swaylock-effects}/bin/swaylock --screenshots --clock --indicator --indicator-radius 100 --indicator-thickness 7 --effect-blur 7x5 --effect-vignette 0.5:0.5 --ring-color bb00cc --key-hl-color 880033";
      }
      {
        timeout = 900; # 15 minutes
        command = "${pkgs.sway}/bin/swaymsg 'output * dpms off'";
        resumeCommand = "${pkgs.sway}/bin/swaymsg 'output * dpms on'";
      }
    ];
    # New syntax: events is now an attrset keyed by event name, value is the command string
    events = {
      "before-sleep" = "${pkgs.swaylock-effects}/bin/swaylock --screenshots --clock --indicator --indicator-radius 100 --indicator-thickness 7 --effect-blur 7x5 --effect-vignette 0.5:0.5 --ring-color bb00cc --key-hl-color 880033";
    };
  };

  # Clipboard history is now handled via cliphist in startup commands

  # SwayFX configuration
  wayland.windowManager.sway = {
    enable = true;
    package = pkgs.swayfx;  # Use SwayFX instead of standard sway
    checkConfig = false;  # Disable config check (fails in build sandbox without DRM FD)
    
    config = {
      # Hyper key definition (Ctrl+Alt+Super)
      modifier = "Mod4"; # Super key
      # Note: Hyper key combinations are defined directly in keybindings
      # $hyper = Mod4+Control+Mod1 (used in keybindings)

      # Standard Sway settings (border, gaps, and workspace settings moved to extraConfig)
      gaps = {
        inner = 8;
      };

      # Keybindings
      keybindings = lib.mkMerge [
        {
          # Reload SwayFX configuration
          "${hyper}+Shift+r" = "reload";
          
          # Rofi Universal Launcher
          "${hyper}+space" = "exec rofi -show combi -combi-modi 'drun,run,window' -show-icons";
          "${hyper}+BackSpace" = "exec rofi -show combi -combi-modi 'drun,run,window' -show-icons";
          # Note: Removed "${hyper}+d" to avoid conflict with application bindings
          # Use "${hyper}+space" or "${hyper}+BackSpace" for rofi launcher
          
          # Window Overview (Mission Control-like)
          "${hyper}+Tab" = "exec ${pkgs.sov}/bin/sov";  # Workspace overview
          
          # Workspace toggle (back and forth)
          "Mod4+Tab" = "workspace back_and_forth";
          
          # Screenshot workflow
          "${hyper}+Shift+x" = "exec ${config.home.homeDirectory}/.config/sway/scripts/screenshot.sh full";
          "${hyper}+Shift+c" = "exec ${config.home.homeDirectory}/.config/sway/scripts/screenshot.sh area";
          "Print" = "exec ${config.home.homeDirectory}/.config/sway/scripts/screenshot.sh area";
          
          # Application keybindings (using app-toggle.sh script)
          # Note: Using different keys to avoid conflicts with window management bindings
          # Format: app-toggle.sh <app_id|class> <launch_command...>
          "${hyper}+T" = "exec ${config.home.homeDirectory}/.config/sway/scripts/app-toggle.sh kitty kitty";
          "${hyper}+R" = "exec ${config.home.homeDirectory}/.config/sway/scripts/app-toggle.sh Alacritty alacritty";
          "${hyper}+L" = "exec ${config.home.homeDirectory}/.config/sway/scripts/app-toggle.sh org.telegram.desktop Telegram";
          "${hyper}+E" = "exec ${config.home.homeDirectory}/.config/sway/scripts/app-toggle.sh io.dbeaver.DBeaverCommunity dbeaver";
          "${hyper}+D" = "exec ${config.home.homeDirectory}/.config/sway/scripts/app-toggle.sh obsidian obsidian --no-sandbox --ozone-platform=wayland --ozone-platform-hint=auto --enable-features=UseOzonePlatform,WaylandWindowDecorations";
          "${hyper}+V" = "exec ${config.home.homeDirectory}/.config/sway/scripts/app-toggle.sh com.vivaldi.Vivaldi vivaldi";
          "${hyper}+G" = "exec ${config.home.homeDirectory}/.config/sway/scripts/app-toggle.sh chromium-browser chromium";
          "${hyper}+Y" = "exec ${config.home.homeDirectory}/.config/sway/scripts/app-toggle.sh spotify spotify --enable-features=UseOzonePlatform --ozone-platform=wayland";
          "${hyper}+N" = "exec ${config.home.homeDirectory}/.config/sway/scripts/app-toggle.sh nwg-look nwg-look";
          "${hyper}+P" = "exec ${config.home.homeDirectory}/.config/sway/scripts/app-toggle.sh Bitwarden bitwarden";
          "${hyper}+C" = "exec ${config.home.homeDirectory}/.config/sway/scripts/app-toggle.sh cursor cursor --enable-features=UseOzonePlatform,WaylandWindowDecorations --ozone-platform-hint=auto --unity-launch";
          "${hyper}+M" = "exec ${config.home.homeDirectory}/.config/sway/scripts/app-toggle.sh mission-center mission-center";
          "${hyper}+B" = "exec ${config.home.homeDirectory}/.config/sway/scripts/app-toggle.sh com.usebottles.bottles bottles";
          
          # Workspace navigation (using Sway native commands for local cycling)
          "${hyper}+Q" = "workspace prev_on_output";  # LOCAL navigation (within current monitor only)
          "${hyper}+W" = "workspace next_on_output";  # LOCAL navigation (within current monitor only)
          "${hyper}+Shift+Q" = "move container to workspace prev_on_output";  # Move window to previous workspace on current monitor (LOCAL)
          "${hyper}+Shift+W" = "move container to workspace next_on_output";  # Move window to next workspace on current monitor (LOCAL)
          
          # Direct workspace bindings (using swaysome)
          "${hyper}+1" = "exec swaysome focus 1";
          "${hyper}+2" = "exec swaysome focus 2";
          "${hyper}+3" = "exec swaysome focus 3";
          "${hyper}+4" = "exec swaysome focus 4";
          "${hyper}+5" = "exec swaysome focus 5";
          "${hyper}+6" = "exec swaysome focus 6";
          "${hyper}+7" = "exec swaysome focus 7";
          "${hyper}+8" = "exec swaysome focus 8";
          "${hyper}+9" = "exec swaysome focus 9";
          "${hyper}+0" = "exec swaysome focus 10";
          
          # Move window to workspace 1-10 (using swaysome)
          "${hyper}+Shift+1" = "exec swaysome move 1";
          "${hyper}+Shift+2" = "exec swaysome move 2";
          "${hyper}+Shift+3" = "exec swaysome move 3";
          "${hyper}+Shift+4" = "exec swaysome move 4";
          "${hyper}+Shift+5" = "exec swaysome move 5";
          "${hyper}+Shift+6" = "exec swaysome move 6";
          "${hyper}+Shift+7" = "exec swaysome move 7";
          "${hyper}+Shift+8" = "exec swaysome move 8";
          "${hyper}+Shift+9" = "exec swaysome move 9";
          "${hyper}+Shift+0" = "exec swaysome move 10";
          
          # Move window between monitors
          "${hyper}+Shift+Left" = "move container to output left";
          "${hyper}+Shift+Right" = "move container to output right";
          
          # Output focus bindings (required since F-keys are removed)
          "${hyper}+Left" = "focus output left";
          "${hyper}+Right" = "focus output right";
          "${hyper}+Up" = "focus output up";
          "${hyper}+Down" = "focus output down";
          
          # Window management (basic - keeping for compatibility)
          "${hyper}+h" = "focus left";
          "${hyper}+j" = "focus down";
          "${hyper}+k" = "focus up";
          # Note: Removed "${hyper}+l" to avoid conflict with "${hyper}+L" (telegram)
          "${hyper}+f" = "fullscreen toggle";
          "${hyper}+Shift+space" = "floating toggle";
          # Note: Removed "${hyper}+s" to avoid conflict with layout bindings
          # Note: Removed "${hyper}+w" to avoid conflict with "${hyper}+W" (workspace next)
          # Note: Removed "${hyper}+e" to avoid conflict with "${hyper}+E" (dolphin)
          
          # Window movement (conditional - floating vs tiled)
          "${hyper}+Shift+j" = "exec ${config.home.homeDirectory}/.config/sway/scripts/window-move.sh left";
          "${hyper}+colon" = "exec ${config.home.homeDirectory}/.config/sway/scripts/window-move.sh right";
          "${hyper}+Shift+k" = "exec ${config.home.homeDirectory}/.config/sway/scripts/window-move.sh down";
          "${hyper}+Shift+l" = "exec ${config.home.homeDirectory}/.config/sway/scripts/window-move.sh up";
          
          # Window focus navigation
          "${hyper}+Shift+comma" = "focus left";  # Changed from Shift+m to avoid conflict with mission-center
          "${hyper}+question" = "focus right";
          "${hyper}+less" = "focus down";
          "${hyper}+greater" = "focus up";
          
          # Window resizing
          "${hyper}+Shift+u" = "resize shrink width 5 ppt";
          "${hyper}+Shift+p" = "resize grow width 5 ppt";
          "${hyper}+Shift+i" = "resize grow height 5 ppt";
          "${hyper}+Shift+o" = "resize shrink height 5 ppt";
          
          # Window management toggles
          "${hyper}+Escape" = "kill";
          "${hyper}+Shift+f" = "floating toggle";
          "${hyper}+Shift+s" = "sticky toggle";
          "${hyper}+Shift+g" = "fullscreen toggle";
          
          # Scratchpad
          "${hyper}+minus" = "scratchpad show";
          "${hyper}+Shift+minus" = "move scratchpad";
          
          # Clipboard history
          "${hyper}+Shift+v" = "exec sh -c '${pkgs.cliphist}/bin/cliphist list | ${pkgs.rofi}/bin/rofi -dmenu | ${pkgs.cliphist}/bin/cliphist decode | ${pkgs.wl-clipboard}/bin/wl-copy'";
          
          # Power menu
          "${hyper}+Shift+BackSpace" = "exec ${config.home.homeDirectory}/.config/sway/scripts/power-menu.sh";
          
          # Toggle SwayFX default bar (swaybar) - disabled by default, can be toggled manually
          "${hyper}+Shift+Home" = "exec ${config.home.homeDirectory}/.config/sway/scripts/swaybar-toggle.sh";
          
          # Hide window (move to scratchpad)
          "${hyper}+Shift+e" = "move scratchpad";
          
          # Exit Sway
          "${hyper}+Shift+End" = "exec swaynag -t warning -m 'You pressed the exit shortcut. Do you really want to exit Sway? This will end your Wayland session.' -b 'Yes, exit Sway' 'swaymsg exit'";
        }
      ];

      # Startup commands (daemons)
      startup = [
        # Initialize swaysome and assign workspace groups to monitors
        # No 'always = true' - runs only on initial startup, not on config reload
        # This prevents jumping back to empty workspaces when editing config
        {
          command = "${config.home.homeDirectory}/.config/sway/scripts/swaysome-init.sh";
        }
        # CRITICAL: Set dark mode environment variables for GTK and Qt apps (both XWayland and Wayland native)
        {
          command = "bash -c 'export GTK_APPLICATION_PREFER_DARK_THEME=1; export GTK_THEME=Adwaita-dark; gsettings set org.gnome.desktop.interface color-scheme prefer-dark 2>/dev/null || true; gsettings set org.gnome.desktop.interface gtk-theme Adwaita-dark 2>/dev/null || true; dbus-update-activation-environment --systemd GTK_APPLICATION_PREFER_DARK_THEME GTK_THEME'";
          always = true;
        }
        # Unified daemon management - starts all daemons with smart reload support
        # Note: Wallpaper (swaybg) is handled by the unified daemon manager
        # CRITICAL: Ensure no 'output * bg' commands exist in config to avoid duplicate wallpaper processes
        {
          command = "${start-sway-daemons}/bin/start-sway-daemons";
          always = true;
        }
        # Sanity check after startup - verifies all daemons started successfully
        # Only runs on initial startup (not on reload) to avoid unnecessary checks
        {
          command = "${daemon-sanity-check}/bin/daemon-sanity-check --fix";
          always = false;  # Only run on initial startup, not on reload
        }
        # DESK-only startup apps (runs after daemons are ready)
        {
          command = "${desk-startup-apps-script}/bin/desk-startup-apps";
          always = false;  # Only run on initial startup, not on config reload
        }
      ];

      # Window rules
      window = {
        commands = [
          # Wayland apps (use app_id)
          { criteria = { app_id = "rofi"; }; command = "floating enable"; }
          { criteria = { app_id = "kitty"; }; command = "floating enable"; }
          { criteria = { app_id = "org.telegram.desktop"; }; command = "floating enable"; }
          { criteria = { app_id = "telegram-desktop"; }; command = "floating enable"; }
          { criteria = { app_id = "bitwarden"; }; command = "floating enable"; }
          { criteria = { app_id = "bitwarden-desktop"; }; command = "floating enable"; }
          { criteria = { app_id = "Bitwarden"; }; command = "floating enable"; }
          { criteria = { app_id = "com.usebottles.bottles"; }; command = "floating enable"; }
          { criteria = { app_id = "swayfx-settings"; }; command = "floating enable"; }
          
          # XWayland apps (use class)
          { criteria = { class = "Spotify"; }; command = "floating enable"; }
          { criteria = { class = "Dolphin"; }; command = "floating enable"; }
          { criteria = { class = "dolphin"; }; command = "floating enable"; }
          
          # Dolphin on Wayland (use app_id)
          { criteria = { app_id = "org.kde.dolphin"; }; command = "floating enable"; }
          
          # Sticky windows - visible on all workspaces of their monitor
          { criteria = { app_id = "kitty"; }; command = "sticky enable"; }
          { criteria = { app_id = "Alacritty"; }; command = "sticky enable"; }
          { criteria = { app_id = "org.telegram.desktop"; }; command = "sticky enable"; }
          { criteria = { app_id = "telegram-desktop"; }; command = "sticky enable"; }
          { criteria = { app_id = "bitwarden"; }; command = "sticky enable"; }
          { criteria = { app_id = "bitwarden-desktop"; }; command = "sticky enable"; }
          { criteria = { app_id = "Bitwarden"; }; command = "sticky enable"; }
          { criteria = { app_id = "org.kde.dolphin"; }; command = "sticky enable"; }
          { criteria = { class = "Dolphin"; }; command = "sticky enable"; }
          { criteria = { class = "dolphin"; }; command = "sticky enable"; }
          { criteria = { class = "Spotify"; }; command = "sticky enable"; }
          
          # DESK startup apps - assign to specific workspaces
          { criteria = { app_id = "com.vivaldi.Vivaldi"; }; command = "move to workspace number 1"; }
          { criteria = { app_id = "cursor"; }; command = "move to workspace number 2"; }
          { criteria = { app_id = "obsidian"; }; command = "move to workspace number 11"; }
          { criteria = { class = "chromium-browser"; }; command = "move to workspace number 12"; }
        ];
      };
    };

    extraConfig = ''
      # Window border settings
      default_border pixel 2
      
      # Disable SwayFX's default internal bar (swaybar) by default
      # Can be toggled manually via ${hyper}+Shift+Home keybinding or: swaymsg bar mode dock/invisible
      bar {
        mode invisible
        hidden_state hide
        position bottom
      }
      
      # CRITICAL: Alt key for Plasma-like window manipulation
      # Alt+drag moves windows, Alt+right-drag resizes windows
      floating_modifier Mod1
      
      # Monitor configuration with scaling and positioning
      # DP-1: Samsung Odyssey G70NC (4K: 3840x2160) - Primary monitor
      # DP-2: NSL RGB-27QHDS (2K: 2560x1440) - Secondary monitor (portrait, right side)
      # Calculations:
      # - DP-1: 3840x2160 @ scale 1.6 = logical 2400x1350
      # - DP-2: 2560x1440 rotated 90° = 1440x2560 @ scale 1.15 = logical 1252x2226
      # - To align bottoms: DP-1 bottom at y=1350, DP-2 bottom should be at y=1350
      # - DP-2 top at y=1350-2226=-876 (extends above DP-1, which is fine)
      # - DP-2 x position: right of DP-1 = 2400
      output "DP-1" {
          scale 1.6
          position 0,0
      }
      output "DP-2" {
          mode 2560x1440@144.000Hz
          scale 1.25
          transform 90
          position 2400,-876
      }
      
      # DP-3 (BenQ): Position left of DP-1
      # Position: negative x to place it left of DP-1
      output "DP-3" {
          position -1920,0
      }
      
      # HDMI-A-1 (Philips): Position right of DP-2
      # DP-2 logical width: 1252, so HDMI-A-1 x = 2400 + 1252 = 3652
      # Align vertically with DP-2 (y = -876 or adjust for alignment)
      output "HDMI-A-1" {
          position 3652,-876
      }
      
      # Workspace-to-monitor assignments with fallbacks
      # DP-1 (Samsung 4K): Workspaces 1-10
      workspace 1 output DP-1
      workspace 2 output DP-1
      workspace 3 output DP-1
      workspace 4 output DP-1
      workspace 5 output DP-1
      workspace 6 output DP-1
      workspace 7 output DP-1
      workspace 8 output DP-1
      workspace 9 output DP-1
      workspace 10 output DP-1
      
      # DP-2 (NSL 2K): Workspaces 11-15 (fallback to DP-1 if DP-2 disconnected)
      workspace 11 output DP-2 DP-1
      workspace 12 output DP-2 DP-1
      workspace 13 output DP-2 DP-1
      workspace 14 output DP-2 DP-1
      workspace 15 output DP-2 DP-1
      
      # DP-3 (BenQ): Workspace 21 (fallback to DP-1 if DP-3 disconnected)
      workspace 21 output DP-3 DP-1
      
      # HDMI-A-1 (Philips): Workspace 31 (fallback to DP-1 if HDMI-A-1 disconnected)
      workspace 31 output HDMI-A-1 DP-1
      
      # Workspace configuration
      workspace_auto_back_and_forth yes
      
      # Disable SwayFX's default internal bar (swaybar) by default
      # Can be toggled manually via swaybar-toggle.sh script or keybinding
      bar bar-0 {
        mode invisible
        hidden_state hide
      }
      
      # SwayFX visual settings matching Khanelinix aesthetic (blur, shadows, rounded corners)
      corner_radius 12
      blur enable
      blur_xray disable
      blur_passes 3
      blur_radius 5
      shadows enable
      shadow_blur_radius 20
      shadow_color #00000070
      
      # Dim inactive windows slightly for focus
      default_dim_inactive 0.1
      
      # Layer effects (Blur the Waybar)
      # CRITICAL: Split into separate lines if chaining not supported
      # NOTE: Previous config had layer_effects commented out due to segfault in SwayFX 0.5.3
      # Test if current SwayFX version supports layer_effects
      # If not supported, blur will still work for windows
      layer_effects "waybar" blur enable
      layer_effects "waybar" corner_radius 12
      layer_effects "waybar" blur enable
      layer_effects "waybar" corner_radius 12
      
      # Keyboard input configuration for polyglot typing (English/Spanish)
      input "type:keyboard" {
        xkb_layout "us"
        xkb_variant "altgr-intl"
      }
      
      # Touchpad configuration
      input "type:touchpad" {
        dwt enabled
        tap enabled
        natural_scroll enabled
        middle_emulation enabled
      }
      
      # Additional SwayFX configuration
      # Floating window rules (duplicate from config.window.commands for reliability)
      for_window [app_id="kitty"] floating enable
      for_window [app_id="org.telegram.desktop"] floating enable
      for_window [app_id="telegram-desktop"] floating enable
      for_window [app_id="bitwarden"] floating enable
      for_window [app_id="bitwarden-desktop"] floating enable
      for_window [app_id="Bitwarden"] floating enable
      for_window [app_id="com.usebottles.bottles"] floating enable
      for_window [app_id="org.kde.dolphin"] floating enable
      for_window [class="Dolphin"] floating enable
      for_window [class="dolphin"] floating enable
      for_window [app_id="rofi"] floating enable
      for_window [app_id="swayfx-settings"] floating enable
      
      # Alacritty: floating and sticky (case variations)
      for_window [app_id="Alacritty"] floating enable, sticky enable
      for_window [app_id="alacritty"] floating enable, sticky enable
      
      # Spotify: floating and sticky (both XWayland and Wayland)
      for_window [class="Spotify"] floating enable, sticky enable
      for_window [app_id="spotify"] floating enable, sticky enable
      
      # Additional floating window rules
      for_window [app_id="pavucontrol"] floating enable
      for_window [app_id="nm-connection-editor"] floating enable
      for_window [app_id="blueman-manager"] floating enable
      for_window [app_id="swappy"] floating enable
      for_window [app_id="swaync"] floating enable
      
      # Focus follows mouse
      focus_follows_mouse yes
      
      # Mouse warping
      mouse_warping output
    '';
  };

  # Sov configuration (Workspace Overview)
  # CRITICAL: Check if Stylix is actually available (not just enabled)
  # Stylix is disabled for Plasma 6 even if stylixEnable is true
  # However, if SwayFX is enabled via enableSwayForDESK, Stylix should be enabled for SwayFX
  home.file.".config/sov/config" = lib.mkIf (systemSettings.stylixEnable == true && (userSettings.wm != "plasma6" || systemSettings.enableSwayForDESK == true)) {
    text = ''
      # Sov configuration with Stylix colors (8-digit hex codes)
      background-color = "#${config.lib.stylix.colors.base00}CC"
      border-color = "#${config.lib.stylix.colors.base02}FF"
      text-color = "#${config.lib.stylix.colors.base07}FF"
      active-workspace-color = "#${config.lib.stylix.colors.base0D}FF"
    '';
  };

  # Btop theme configuration (Stylix colors)
  # CRITICAL: Check if Stylix is actually available (not just enabled)
  # Stylix is disabled for Plasma 6 even if stylixEnable is true
  # However, if SwayFX is enabled via enableSwayForDESK, Stylix should be enabled for SwayFX
  home.file.".config/btop/btop.conf" = lib.mkIf (systemSettings.stylixEnable == true && (userSettings.wm != "plasma6" || systemSettings.enableSwayForDESK == true)) {
    text = ''
      # Btop Configuration
      # Theme matching Stylix colors
      
      theme_background = "#${config.lib.stylix.colors.base00}"
      theme_text = "#${config.lib.stylix.colors.base07}"
      theme_title = "#${config.lib.stylix.colors.base0D}"
      theme_hi_fg = "#${config.lib.stylix.colors.base0A}"
      theme_selected_bg = "#${config.lib.stylix.colors.base0D}"
      theme_selected_fg = "#${config.lib.stylix.colors.base07}"
      theme_cpu_box = "#${config.lib.stylix.colors.base0B}"
      theme_mem_box = "#${config.lib.stylix.colors.base0E}"
      theme_net_box = "#${config.lib.stylix.colors.base0C}"
      theme_proc_box = "#${config.lib.stylix.colors.base09}"
    '';
  };

  # Libinput-gestures configuration for SwayFX
  # 3-finger swipe for workspace navigation (matches keybindings: next_on_output/prev_on_output)
  # Uses next_on_output/prev_on_output to prevent gestures from jumping between monitors
  xdg.configFile."libinput-gestures.conf".text = ''
    # Libinput-gestures configuration for SwayFX
    # 3-finger swipe for workspace navigation (matches keybindings: next_on_output/prev_on_output)
    
    gesture swipe left 3 ${pkgs.swayfx}/bin/swaymsg workspace next_on_output
    gesture swipe right 3 ${pkgs.swayfx}/bin/swaymsg workspace prev_on_output
    # Optional: 3-finger swipe up for fullscreen toggle
    # gesture swipe up 3 ${pkgs.swayfx}/bin/swaymsg fullscreen toggle
  '';

  # Install scripts to .config/sway/scripts/
  home.file.".config/sway/scripts/screenshot.sh" = {
    source = ./scripts/screenshot.sh;
    executable = true;
  };
  
  home.file.".config/sway/scripts/ssh-smart.sh" = {
    source = ./scripts/ssh-smart.sh;
    executable = true;
  };
  
  home.file.".config/sway/scripts/app-toggle.sh" = {
    source = ./scripts/app-toggle.sh;
    executable = true;
  };
  
  home.file.".config/sway/scripts/window-move.sh" = {
    source = ./scripts/window-move.sh;
    executable = true;
  };
  
  home.file.".config/sway/scripts/power-menu.sh" = {
    source = ./scripts/power-menu.sh;
    executable = true;
  };
  
  home.file.".config/sway/scripts/swaysome-init.sh" = {
    source = ./scripts/swaysome-init.sh;
    executable = true;
  };
  
  # Generate swaybar-toggle script with proper package paths
  home.file.".config/sway/scripts/swaybar-toggle.sh" = {
    text = ''
      #!/bin/sh
      # Toggle SwayFX's default bar (swaybar) visibility
      # The bar is disabled by default in the config (mode invisible)
      # This script allows manual toggling when needed

      # Get current bar mode
      CURRENT_MODE=$(${pkgs.swayfx}/bin/swaymsg -t get_bar_config bar-0 | ${pkgs.jq}/bin/jq -r '.mode' 2>/dev/null)

      if [ "$CURRENT_MODE" = "invisible" ] || [ -z "$CURRENT_MODE" ]; then
        # Bar is invisible or doesn't exist - show it
        ${pkgs.swayfx}/bin/swaymsg bar bar-0 mode dock
        # Optional notification (fails gracefully if libnotify not available)
        command -v notify-send >/dev/null 2>&1 && notify-send -t 2000 "Swaybar" "Bar enabled (dock mode)" || true
      else
        # Bar is visible - hide it
        ${pkgs.swayfx}/bin/swaymsg bar bar-0 mode invisible
        # Optional notification (fails gracefully if libnotify not available)
        command -v notify-send >/dev/null 2>&1 && notify-send -t 2000 "Swaybar" "Bar disabled (invisible mode)" || true
      fi
    '';
    executable = true;
  };
  
  # NOTE: waybar-startup.sh and dock-diagnostic.sh have been removed
  # They were orphaned scripts superseded by daemon-manager
  # waybar-startup.sh functionality is now in daemon-manager
  # dock-diagnostic.sh was diagnostic-only and not used in startup
  
  # Add generated daemon management scripts to PATH
  home.packages = [
    daemon-manager
    start-sway-daemons
    daemon-sanity-check
    desk-startup-apps-script
  ] ++ (with pkgs; [
    # SwayFX and related
    swayfx
    swaylock-effects
    swayidle
    swaynotificationcenter
    waybar  # Waybar status bar (also configured via programs.waybar)
    sov  # Workspace overview for SwayFX
    swaysome  # Workspace namespace per monitor
    
    # Screenshot workflow
    grim
    slurp
    swappy
    swaybg  # Wallpaper manager
    
    # Universal launcher
    rofi  # rofi-wayland has been merged into rofi (as of 2025-09-06)
    
    # Gaming tools
    gamescope
    mangohud
    
    # AI workflow (aichat is installed via module)
    
    # Terminal and tools
    jq  # CRITICAL: Required for screenshot script
    wl-clipboard
    cliphist  # Clipboard history manager for Wayland
    
    # Touchpad gestures
    libinput-gestures
    
    # System tools
    networkmanagerapplet
    blueman
    polkit_gnome
    
    # System monitoring
    # btop is installed by system/hardware/gpu-monitoring.nix module
    # AMD profiles get btop-rocm, Intel/others get standard btop
  ]);
}

