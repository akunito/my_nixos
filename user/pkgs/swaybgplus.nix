{ lib
, stdenvNoCC
, fetchFromGitHub
, makeWrapper
, wrapGAppsHook3
, python3
, gtk3
, gobject-introspection
, coreutils
, procps
, sway
, swaybg
}:

let
  pythonEnv = python3.withPackages (ps: [
    ps.pillow
    ps.pygobject3
    ps.pycairo
  ]);
in
stdenvNoCC.mkDerivation rec {
  pname = "swaybgplus";
  version = "unstable-2026-01-09";

  src = fetchFromGitHub {
    owner = "alephpt";
    repo = "swaybgplus";
    rev = "d97bc8ca2582dd781e5b23b9f3cc2634417d33cb";
    # NOTE: fetchFromGitHub hashes the *unpacked* content (like `nix store prefetch-file --unpack`).
    hash = "sha256-/Eb0D4zeK2AbFOvSlLC+j3Dh1vOVqx9MybAuBOofsEo=";
  };

  # Needed so GI can load Gtk typelibs ("Gtk-3.0.typelib") and so GTK apps get a sane runtime env.
  buildInputs = [
    gtk3
    gobject-introspection
  ];

  # Apply NixOS/Home-Manager compatibility patches to upstream swaybgplus.
  postPatch = ''
    ${python3}/bin/python3 - <<'PY'
import os

def patch_sway_config_parser():
    path = "sway_config_parser.py"
    s = open(path, "r", encoding="utf-8").read()

    # Track where we saved to (for UI messaging).
    if "self.last_saved_path" not in s:
        s = s.replace(
            '        self.config_content = ""',
            '        self.config_content = ""\n        self.last_saved_path = None\n        self.last_saved_is_fallback = False',
            1,
        )

    # In HM-managed Sway sessions, ~/.config/sway/config is a symlink into /nix/store (read-only).
    # Save output lines to a writable include file instead.
    marker = "def save_config_file(self, backup: bool = True) -> bool:\n"
    start = s.find(marker)
    if start < 0:
        raise SystemExit("save_config_file not found")
    try_pos = s.find("\n        try:\n", start)
    if try_pos < 0:
        raise SystemExit("save_config_file try not found")
    if "swaybgplus-outputs.conf" not in s[start:start+2000]:
        inject = (
            "        try:\n"
            "            real = os.path.realpath(self.config_path) if self.config_path else \"\"\n"
            "            if (self.config_path and (os.path.islink(self.config_path) or real.startswith(\"/nix/store\"))):\n"
            "                fallback = os.path.expanduser(\"~/.config/sway/swaybgplus-outputs.conf\")\n"
            "                os.makedirs(os.path.dirname(fallback), exist_ok=True)\n"
            "                self.last_saved_path = fallback\n"
            "                self.last_saved_is_fallback = True\n"
            "                lines = [\"# Output configurations (generated by SwayBG+)\"]\n"
            "                for output in self.outputs:\n"
            "                    if output.enabled:\n"
            "                        line = (f\"output {output.name} res {output.resolution[0]}x{output.resolution[1]} pos {output.position[0]} {output.position[1]} scale {output.scale}\")\n"
            "                        if output.transform != \"normal\":\n"
            "                            line += f\" transform {output.transform}\"\n"
            "                        lines.append(line)\n"
            "                    else:\n"
            "                        lines.append(f\"output {output.name} disable\")\n"
            "                with open(fallback, \"w\", encoding=\"utf-8\") as f:\n"
            "                    f.write(\"\\n\".join(lines) + \"\\n\")\n"
            "                return True\n"
            "            self.last_saved_path = self.config_path\n"
            "            self.last_saved_is_fallback = False\n"
        )
        s = s[:try_pos] + "\n" + inject + s[try_pos + len("\n        try:\n"):]

    open(path, "w", encoding="utf-8").write(s)

def patch_gui():
    gui_path = "swaybgplus_gui.py"
    sg = open(gui_path, "r", encoding="utf-8").read()

    # Improve save dialog message for HM read-only config.
    if "last_saved_is_fallback" not in sg:
        sg = sg.replace(
            "            success = self.parser.save_config_file(backup=True)\n            if success:\n                self.mark_config_saved()  # Mark as saved\n                self.show_info(\"Monitor Configuration Saved\", \n                             \"Monitor configuration has been saved to the sway config file.\\n\"\n                             \"A backup was created with .backup extension.\")",
            "            success = self.parser.save_config_file(backup=True)\n            if success:\n                self.mark_config_saved()  # Mark as saved\n                saved_path = getattr(self.parser, 'last_saved_path', self.parser.get_config_path())\n                is_fallback = bool(getattr(self.parser, 'last_saved_is_fallback', False))\n                if is_fallback:\n                    self.show_info(\"Monitor Configuration Saved\",\n                                 f\"Your main Sway config is Home-Manager managed (read-only).\\n\\nSaved output lines to:\\n{saved_path}\\n\\nTo apply changes: run `swaymsg reload` (or reload Sway) after saving.\")\n                else:\n                    self.show_info(\"Monitor Configuration Saved\",\n                                 \"Monitor configuration has been saved to the sway config file.\\n\"\n                                 \"A backup was created with .backup extension.\")",
            1,
        )

    # Add an Apply button to actually set wallpaper (upstream Save is monitor config only).
    if "def on_apply_background(" not in sg:
        anchor = (
            "load_image_btn = Gtk.Button.new_with_label(\"ðŸ“ Load Image\")\n"
            "        load_image_btn.connect('clicked', self.on_load_image)\n"
            "        image_controls_box.pack_end(load_image_btn, False, False, 0)\n"
        )
        if anchor in sg:
            sg = sg.replace(
                anchor,
                anchor
                + "\n        # Apply background button\n        apply_bg_btn = Gtk.Button.new_with_label(\"âœ… Apply\")\n        apply_bg_btn.connect('clicked', self.on_apply_background)\n        apply_bg_btn.set_tooltip_text(\"Apply wallpaper using swaybg\")\n        image_controls_box.pack_end(apply_bg_btn, False, False, 0)\n",
                1,
            )

        insert_after = "    def on_load_image(self, button):\n        \"\"\"Handle load image button\"\"\"\n"
        idx = sg.find(insert_after)
        if idx != -1:
            next_def = sg.find("\n    def ", idx + len(insert_after))
            if next_def != -1:
                handler = """

    def on_apply_background(self, button):
        \"\"\"Apply the current image as wallpaper using swaybg\"\"\"
        if not self.current_image_path:
            self.show_error("No image loaded. Please load an image first.")
            return

        mode = (self.current_mode or "stretched").lower()
        image_offset = getattr(self.monitor_widget, "image_offset", (0, 0))
        image_scale = float(getattr(self.monitor_widget, "image_scale", 1.0))
        try:
            if mode == "stretched":
                ok = self.background_manager.set_background_stretched(self.current_image_path, None, image_offset, image_scale)
            else:
                ok = self.background_manager.set_background_fitted(self.current_image_path, None, mode, image_offset, image_scale)

            if ok:
                self.background_applied = True
                self.save_original_image_path(self.current_image_path)
                self.update_status("Background applied")
            else:
                self.show_error("Failed to apply background")
        except Exception as e:
            self.show_error(f"Error applying background: {e}")
"""
                sg = sg[:next_def] + handler + sg[next_def:]

    open(gui_path, "w", encoding="utf-8").write(sg)

def patch_background_manager():
    # Disable upstream "startup script" injection into sway config; we manage restore via systemd user service.
    bm_path = "background_manager.py"
    bm = open(bm_path, "r", encoding="utf-8").read()

    # Persist wallpaper state under XDG_STATE_HOME so Home-Manager rebuilds don't clobber it.
    # Keep legacy compatibility by migrating from ~/.config/sway/backgrounds on first run.
    bm = bm.replace(
        '        self.config_dir = os.path.expanduser("~/.config/sway/backgrounds")',
        '        state_home = os.environ.get("XDG_STATE_HOME", os.path.expanduser("~/.local/state"))\n'
        '        self.config_dir = os.path.join(state_home, "swaybgplus", "backgrounds")',
        1,
    )
    if "legacy_dir = os.path.expanduser(\"~/.config/sway/backgrounds\")" not in bm:
        bm = bm.replace(
            "        self.ensure_config_dir()",
            "        self.ensure_config_dir()\n"
            "\n"
            "        # Migrate legacy config (~/.config/sway/backgrounds) -> XDG_STATE_HOME/swaybgplus/backgrounds\n"
            "        legacy_dir = os.path.expanduser(\"~/.config/sway/backgrounds\")\n"
            "        try:\n"
            "            legacy_cfg = os.path.join(legacy_dir, \"current_config.json\")\n"
            "            new_cfg = os.path.join(self.config_dir, \"current_config.json\")\n"
            "            if os.path.exists(legacy_cfg) and not os.path.exists(new_cfg):\n"
            "                os.makedirs(self.config_dir, exist_ok=True)\n"
            "                shutil.copy2(legacy_cfg, new_cfg)\n"
            "                for f in os.listdir(legacy_dir):\n"
            "                    if f.endswith((\".png\", \".jpg\", \".jpeg\")) and f != \"current_config.json\":\n"
            "                        src = os.path.join(legacy_dir, f)\n"
            "                        dst = os.path.join(self.config_dir, f)\n"
            "                        if os.path.exists(src) and not os.path.exists(dst):\n"
            "                            shutil.copy2(src, dst)\n"
            "        except Exception:\n"
            "            pass",
            1,
        )

    bm = bm.replace(
        "            # Create startup script\n            self.create_startup_script()\n",
        "            # Startup integration is handled by systemd (swaybgplus-restore.service); do not edit sway config.\n",
    )
    open(bm_path, "w", encoding="utf-8").write(bm)

patch_sway_config_parser()
patch_gui()
patch_background_manager()
PY
  '';

  nativeBuildInputs = [
    makeWrapper
    wrapGAppsHook3
  ];

  installPhase = ''
    runHook preInstall

    mkdir -p $out/share/swaybgplus
    cp -R . $out/share/swaybgplus

    mkdir -p $out/bin

    # CLI wrapper
    makeWrapper ${pythonEnv}/bin/python3 $out/bin/swaybgplus \
      --add-flags "$out/share/swaybgplus/swaybgplus_cli.py" \
      --prefix GI_TYPELIB_PATH : "${lib.makeSearchPath "lib/girepository-1.0" [ gtk3 gobject-introspection ]}" \
      --prefix PATH : ${lib.makeBinPath [ swaybg procps sway coreutils ]}

    # GUI wrapper
    makeWrapper ${pythonEnv}/bin/python3 $out/bin/swaybgplus-gui \
      --add-flags "$out/share/swaybgplus/swaybgplus_gui.py" \
      --prefix GI_TYPELIB_PATH : "${lib.makeSearchPath "lib/girepository-1.0" [ gtk3 gobject-introspection ]}" \
      --prefix PATH : ${lib.makeBinPath [ swaybg procps sway coreutils ]}

    runHook postInstall
  '';

  meta = {
    description = "SwayBG+ - advanced multi-monitor background manager for Sway (GUI + CLI)";
    homepage = "https://github.com/alephpt/swaybgplus";
    license = lib.licenses.mit;
    platforms = lib.platforms.linux;
    mainProgram = "swaybgplus";
  };
}


